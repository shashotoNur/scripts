#!/usr/bin/env bash
# diskscan - fzf-select a disk and show partition usage in GiB with colored percentages
set -euo pipefail

# --- Colors (ANSI-C quoting ensures real escape codes) ---
RED=$'\e[0;31m'; YELLOW=$'\e[1;33m'; GREEN=$'\e[0;32m'; CYAN=$'\e[0;36m'
BOLD=$'\e[1m'; RESET=$'\e[0m'

trap 'printf "%b\n" "${RED}Error: command failed on line $LINENO.${RESET}" >&2' ERR

# --- Check required commands ---
for cmd in lsblk fzf df awk; do
  command -v "$cmd" >/dev/null 2>&1 || { printf "%b\n" "${RED}Missing: $cmd${RESET}"; exit 1; }
done

printf "%bSelect a disk:%b\n" "$CYAN" "$RESET"
disk=$(lsblk -dpno NAME,SIZE,MODEL | fzf --prompt="Choose a disk > " --height=40% --reverse | awk '{print $1}')
[[ -z "${disk:-}" ]] && { printf "%bNo disk selected. Exiting.%b\n" "$YELLOW" "$RESET"; exit 0; }

printf "\n%bAnalyzing partitions of %s...%b\n\n" "$BOLD" "$disk" "$RESET"

# --- Collect lsblk data (flat) ---
mapfile -t entries < <(lsblk -rno NAME,TYPE,MOUNTPOINT "$disk")

declare -A parts crypts
for l in "${entries[@]}"; do
  name=$(awk '{print $1}' <<<"$l")
  type=$(awk '{print $2}' <<<"$l")
  mnt=$(awk '{print $3}' <<<"$l")
  parts["$name"]="$type|$mnt"
  [[ "$type" == "crypt" ]] && crypts["$name"]=1
done

# --- Build partition list (skip base of opened LUKS) ---
partitions=()
for name in "${!parts[@]}"; do
  type=${parts["$name"]%%|*}
  if [[ "$type" == "crypt" ]]; then
    partitions+=("/dev/mapper/$name")
  elif [[ "$type" == "part" && ! -v crypts["$name"] ]]; then
    partitions+=("/dev/$name")
  fi
done
(( ${#partitions[@]} == 0 )) && { printf "%bNo valid partitions for %s%b\n" "$YELLOW" "$disk" "$RESET"; exit 0; }

# --- Table header ---
printf "%-38s %-27s %-30s\n" "${BOLD}Partition${RESET}" "${BOLD}Used (GiB)${RESET}" "${BOLD}Free (GiB)${RESET}"
printf "%s\n" "--------------------------------------------------------------------------------"

total_used=0; total_avail=0

for p in "${partitions[@]}"; do
  mnt=$(lsblk -no MOUNTPOINT "$p" 2>/dev/null | head -n1 || true)
  if [[ -z "$mnt" ]]; then
    printf "%-30s %-30s %-30s\n" "$p" "-" "${YELLOW}unmounted${RESET}"
    continue
  fi

  dfline=$(df -BG --output=size,used,avail,pcent "$mnt" 2>/dev/null | tail -n1 || true)
  [[ -z "$dfline" ]] && { printf "%-30s %-30s %-30s\n" "$p" "-" "${RED}error${RESET}"; continue; }

  read -r sizeG usedG availG usedPctRaw <<<"$(awk '{print $1,$2,$3,$4}' <<<"$dfline")"
  size=${sizeG%G}; used=${usedG%G}; avail=${availG%G}; usedpct=${usedPctRaw%\%}
  freepct=$(( size > 0 ? 100 - usedpct : 0 ))

  total_used=$((total_used + used))
  total_avail=$((total_avail + avail))

  # pick colors for used% and free%
  if (( usedpct >= 90 )); then upcol=$RED
  elif (( usedpct >= 70 )); then upcol=$YELLOW
  else upcol=$GREEN
  fi
  if (( freepct <= 10 )); then fpcol=$RED
  elif (( freepct <= 30 )); then fpcol=$YELLOW
  else fpcol=$GREEN
  fi

  used_field="${used} ${upcol}(${usedpct}%)${RESET}"
  free_field="${avail} ${fpcol}(${freepct}%)${RESET}"

  # use "%s" for every field to avoid treating "-" as option
  printf "%-30s %-30s %-30s\n" "$p" "$used_field" "$free_field"
done

printf "%s\n" "--------------------------------------------------------------------------------"
total=$((total_used + total_avail))
usedpct=$(( total > 0 ? total_used * 100 / total : 0 ))
freepct=$(( 100 - usedpct ))

# total colors
[[ $usedpct -ge 90 ]] && upcol=$RED || ([[ $usedpct -ge 70 ]] && upcol=$YELLOW || upcol=$GREEN)
[[ $freepct -le 10 ]] && fpcol=$RED || ([[ $freepct -le 30 ]] && fpcol=$YELLOW || fpcol=$GREEN)

used_field="${total_used} ${upcol}(${usedpct}%)${RESET}"
free_field="${total_avail} ${fpcol}(${freepct}%)${RESET}"
printf "%-38s %-30s %-30s\n\n" "${BOLD}TOTAL${RESET}" "$used_field" "$free_field"
