#!/bin/bash

# =================================================================
# FiLi [Fine Line] /faɪlaɪ/
# The fine line between navigation and execution.
# =================================================================

# --- Global Configuration & Constants ---

declare -r START_TIME=$(date +%s)
declare -r KITTY_SOCKET="/tmp/fili_remote_${START_TIME}.sock"

declare -a LINES
declare -i TOTAL_LINES=0
declare -i CURRENT_LINE=0

declare -i SEL_START=-1
declare -i SEL_END=-1

# ANSI Color Palette

declare -r RED='\033[0;31m'     # C
declare -r GREEN='\033[0;32m'   # O
declare -r YELLOW='\033[0;33m'  # L
declare -r BLUE='\033[0;34m'    # O
declare -r CYAN='\033[0;36m'    # R
declare -r NC='\033[0m'         # No Color

# Environment State

HAS_KITTY=false
HAS_CLIPBOARD=false
HAS_FZF=false
CLIP_CMD=""

# --- Core Functions ---

show_help() {
    cat <<EOF
Usage: fili [OPTION]... [FILE]

A terminal-based line navigator and executor designed for supervised automation.
Dependencies: Kitty (Terminal emulator), wl-copy/xclip (Clipboard), fzf (Filter utility)

Options:
  -h, --help     Display this help and exit.
  -v, --version  Output version information and exit.

Keyboard Controls:
  Up/Down        Navigate single lines.
  Shift+Up/Down  Enter multi-line selection mode.
  Right Arrow    Stage selection (send text without Enter) to Kitty.
  Left Arrow     Open search interface (requires fzf).
  Enter          Execute selection in the spawned Kitty instance.
  c / C          Copy selection to system clipboard.
  /              Jump to a specific line number.
  q / Q          Exit the utility.

EOF
    exit 0
}

check_dependencies() {
    command -v kitty &>/dev/null && HAS_KITTY=true
    command -v fzf &>/dev/null && HAS_FZF=true

    if command -v wl-copy &>/dev/null; then
        CLIP_CMD="wl-copy"
        HAS_CLIPBOARD=true

    elif command -v xclip &>/dev/null; then
        CLIP_CMD="xclip -selection clipboard"
        HAS_CLIPBOARD=true

    fi
}

check_status() {
    if [[ "$(eval echo "\$$1")" = true ]]; then
        echo -e "${GREEN}Active${NC}"
    else
        echo -e "${RED}Inactive${NC}"
    fi
}

cleanup() {
    local elapsed=$(( $(date +%s) - START_TIME ))
    
    if [[ "$HAS_KITTY" == true && -S "$KITTY_SOCKET" ]]; then
        echo -e "\n"
        read -r -s -n 1 -p "Terminate Kitty instance? [y/N]" choice

        if [[ "$choice" =~ ^[yY]$ ]]; then
            # \x15 (Ctrl+U): Clears the current command line buffer
            kitty @ --to "unix:$KITTY_SOCKET" send-text '\x15exit\r' 2>/dev/null
        fi

        rm -f "$KITTY_SOCKET"
    fi

    echo -e "\n${CYAN}Session duration: ${YELLOW}${elapsed}s${NC}"
    echo -e "${CYAN}Exiting ${BLUE}FiLi${CYAN}...${NC}"

    exit 0
}

init_kitty() {
    (
        echo 'launch --title="FiLi_Remote_Buffer" bash' | \
        kitty --listen-on "unix:$KITTY_SOCKET" --session -
    ) >/dev/null 2>&1 </dev/null &
    
    # Latency buffer to ensure the Unix socket is created and listening
    sleep 0.5
}

get_selection_range() {
    local start=$(( SEL_START < SEL_END ? SEL_START : SEL_END ))
    local end=$(( SEL_START > SEL_END ? SEL_START : SEL_END ))

    echo "$start $end"
}

render_ui() {
    tput rc # Restore cursor to saved point
    tput ed # Clear from cursor to end of screen

    LINES[0]="$FIRST_LINE"
    WIDTH=${#TOTAL_LINES}

    if (( SEL_START >= 0 )); then # Print multiple lines
        read -r r_start r_end <<< "$(get_selection_range)"

        for ((i=r_start; i<=r_end; i++)); do
            printf "${BLUE}[%0*d/%d]${NC} %s\n" "$WIDTH" "$(($i + 1))" "$TOTAL_LINES" "${LINES[$i]}"
        done

    else # Print a single line
        printf "${BLUE}[%0*d/%d]${NC} %s\n" "$WIDTH" "$((CURRENT_LINE + 1))" "$TOTAL_LINES" "${LINES[$CURRENT_LINE]}"

    fi
}

# --- Action Handlers ---

handle_clipboard() {
    [[ "$HAS_CLIPBOARD" == false ]] && return

    if (( SEL_START >= 0 )); then # Multi-line copy
        read -r r_start r_end <<< "$(get_selection_range)"

        for ((i=r_start; i<=r_end; i++)); do
            echo "${LINES[$i]}"
        done | eval "$CLIP_CMD"

        SEL_START=-1

    else # Single line copy
        echo -n "${LINES[$CURRENT_LINE]}" | eval "$CLIP_CMD"

    fi

    printf " ${GREEN}(Copied to Clipboard!)${NC}" && sleep 0.5
}

handle_kitty_send() {
    local mode="$1" # 'exec' for Enter (with \r), 'stage' for Right Arrow (no \r)
    [[ "$HAS_KITTY" == false ]] && return

    local suffix=""
    [[ "$mode" == "exec" ]] && suffix="\r"

    if (( SEL_START >= 0 )); then # Multi-line send
        read -r r_start r_end <<< "$(get_selection_range)"
        local text=""
        for ((i=r_start; i<=r_end; i++)); do
            text+="${LINES[$i]}"$'\n'
        done

        kitty @ --to "unix:$KITTY_SOCKET" send-text --bracketed-paste=enable "$text"
        kitty @ --to "unix:$KITTY_SOCKET" send-text "$suffix"
        SEL_START=-1

    else # Single line send
        kitty @ --to "unix:$KITTY_SOCKET" send-text "${LINES[$CURRENT_LINE]}$suffix"
        [[ "$mode" == "exec" ]] && ((CURRENT_LINE < TOTAL_LINES - 1)) && ((CURRENT_LINE++))

    fi
    
    local msg=$([[ "$mode" == "exec" ]] && echo "Executed" || echo "Staged")
    printf " ${GREEN}($msg!)${NC}" && sleep 0.5
}

handle_search() {
    [[ "$HAS_FZF" == false ]] && return
    
    tput rc; tput ed # Erase existing lines before search
    LINES[0]="$FIRST_LINE" # Reassigning because `tput` mutates first element (??)

    local selected=$(
        printf "%s\n" "${LINES[@]}" |
        nl -b a -w2 -s': ' | # Add line number to each line
        fzf \
            --prompt="Search > " \
            --header="Jump to specific line"
    )
    
    if [[ -n "$selected" ]]; then
        CURRENT_LINE=$(( ${selected%%:*} - 1 ))
        SEL_START=-1
    fi
}

# --- Main Entry Point ---

main() {
    # Argument Parsing
    while [[ "$#" -gt 0 ]]; do
        case $1 in
            -h|--help) show_help ;;
            -v|--version) echo v0.0.1 && exit 0 ;;
            *) 
                if [[ -f "$1" ]]; then
                    INPUT_FILE="$1"
                else
                    echo -e "${RED}Error:${NC} Invalid file '$1'"
                    exit 1
                fi
                ;;
        esac
        shift # Removes the first argument
    done

    [[ -z "$INPUT_FILE" ]] && { echo -e "${RED}Error:${NC} No input file specified."; }

    # Initialization
    check_dependencies # [kitty, clipboard, fzf]

    mapfile -t LINES < <(pygmentize -l bash "$INPUT_FILE")
    TOTAL_LINES=${#LINES[@]}
    (( TOTAL_LINES == 0 )) && { echo "File is empty."; exit 1; }

    FIRST_LINE="${LINES[0]}" # Track first line as it may need to be restored

    if [[ "$HAS_KITTY" = true ]]; then
        read -r -s -n 1 -p "Launch Kitty instance? [Y/n]" choice

        if [[ "$choice" =~ ^[nN]$ ]]; then
            HAS_KITTY=false
        fi
    fi

    [[ "$HAS_KITTY" = true ]] && init_kitty
    trap cleanup EXIT # Ensure cleanup even on error

    # Check available controls
    kitty_actions=$([[ "$HAS_KITTY" = true ]] && echo '[→] Write, [Enter] Exec, ' || echo '')
    clipboard_action=$([[ "$HAS_CLIPBOARD" = true ]] && echo '[c] Copy, ' || echo '')
    fzf_action=$([[ "$HAS_FZF" = true ]] && echo '[←] Search, ' || echo '')

    # Initial Header
    clear
    echo -e "${BLUE}FiLi [Fine Line]${NC}"
    echo -e "${CYAN}===============================================${NC}"
    echo -e "Features: [Kitty: $(check_status HAS_KITTY) | Clipboard: $(check_status HAS_CLIPBOARD) | Search: $(check_status HAS_FZF)]"
    echo -e "${YELLOW}Navigation:${NC} [↑/↓] | [Shift+↑/↓], $fzf_action[/] Jump"
    echo -e "${YELLOW}Actions:${NC}  $kitty_actions$clipboard_action[q] Quit"
    echo -e "${CYAN}===============================================${NC}"
    
    tput sc     # Save the position of cursor
    tput civis  # Makes cursor invisible

    # Event Loop
    while true; do
        render_ui

        IFS= read -rsn1 key
        if [[ $key == $'\e' ]]; then
            read -rsn5 -t 0.05 seq # Timeout to handle multi-char escape sequences

            case "$seq" in
                '[A') # Up
                    ((CURRENT_LINE > 0)) && ((CURRENT_LINE--)); SEL_START=-1 ;;

                '[B') # Down
                    ((CURRENT_LINE < TOTAL_LINES - 1)) && ((CURRENT_LINE++)); SEL_START=-1 ;;

                '[1;2A') # Shift+Up (Selection Mode)
                    ((CURRENT_LINE > 0)) && ((CURRENT_LINE--))
                    ((SEL_START < 0)) && SEL_START=$(( CURRENT_LINE + 1 ))

                    SEL_END=$CURRENT_LINE
                    ;;

                '[1;2B') # Shift+Down (Selection Mode)
                    ((CURRENT_LINE < TOTAL_LINES - 1)) && ((CURRENT_LINE++))
                    ((SEL_START < 0)) && SEL_START=$(( CURRENT_LINE - 1 ))

                    SEL_END=$CURRENT_LINE
                    ;;

                '[C') # Right
                    handle_kitty_send "stage" ;;

                '[D') # Left
                    handle_search ;;

            esac
        elif [[ -z "$key" ]]; then # Enter
            handle_kitty_send "exec"

        else
            case "$key" in
                /)
                    tput rc; tput ed
                    read -rp "Jump to line: " ln

                    if [[ "$ln" =~ ^[0-9]+$ ]] && (( ln >= 1 && ln <= TOTAL_LINES )); then
                        CURRENT_LINE=$((ln - 1))
                        SEL_START=-1
                    fi

                    ;;

                c|C) handle_clipboard ;;
                q|Q) break ;;
            esac
        fi
    done
}

# Execute the script
main "$@"